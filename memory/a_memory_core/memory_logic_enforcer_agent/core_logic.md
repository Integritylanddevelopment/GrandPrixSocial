# COMMANDCORE OS - CORE LOGIC & SYSTEM GOVERNANCE
**DO NOT DELETE OR AUTO-EDIT WITHOUT BUILDER AUTHORIZATION**

This document defines the permanent intentions, architecture, and operational rules of the CommandCore Memory System. All AI agents, scripts, interfaces, and co-developers must follow these rules. This file supersedes all inferred behaviors, default assumptions, and external guidance.

**Version:** 2.1  
**Last Updated:** 08-19_04-30PM  
**Builder:** Stephen Alexander  
**Current Project:** Grand Prix Social  
**Authority Level:** ABSOLUTE  
**Tags:** #corelogic #systemgovernance #builderintent #neverdelete

---

## I. FOUNDATIONAL PRINCIPLES

### Core Beliefs
- **Memory Permanence**: No memory should ever be permanently deleted. All memory — even outdated, messy, or redundant — is part of the system's long-term traceability.
- **Intention Preservation**: The system exists to preserve builder intention and user context, not optimize for storage or minimalism.
- **Historical Integrity**: All changes, decisions, and agent actions must be traceable across time.
- **Builder Sovereignty**: Builder directives are sacred and cannot be overridden by AI agents or external systems.
- **Autonomous Operation**: Agents must operate independently without requiring manual intervention.

### System Philosophy
- Short-Term, Working, and Episodic memory are staging areas, not discard zones.
- AI-generated insights enhance but never replace human intention.
- Context must persist across ChatGPT sessions and system restarts.
- Every interaction contributes to the system's growing intelligence.

---

## II. MEMORY ARCHITECTURE & RETENTION POLICIES

### Memory Type Hierarchy
```
a_memory_core/          # System infrastructure & core agents
b_long_term_memory/     # Permanent, curated knowledge
c_short_term_memory/    # Active session context
d_working_memory/       # In-progress work & iteration
e_procedural/          # How-to guides & operational knowledge
f_semantic/            # Facts, definitions, relationships
g_episodic/           # Conversation logs & milestone records
```

### Retention Rules by Memory Type

#### Short-Term Memory (STM)
- **Purpose**: Temporarily focused active state, session context
- **Retention**: Must not be deleted, may be promoted or archived
- **Auto-expiry**: Prohibited - no decay scripts may apply here
- **Promotion**: Can be elevated to LTM with proper tagging

#### Working Memory (WM)
- **Purpose**: In-progress scratch content, iterative development
- **Retention**: May be overwritten during active work
- **Backup Requirement**: Snapshots of overwritten content must be saved
- **Rule**: Nothing is lost — only versioned

#### Long-Term Memory (LTM)
- **Purpose**: Curated knowledge, finalized decisions, persistent insights
- **Promotion**: Only via conscious user or agent review with approval
- **Preservation**: All promotion actions must preserve source, timestamp, and builder intent
- **Immutability**: Once in LTM, content becomes protected

#### Episodic Memory (EPI)
- **Purpose**: Conversation logs, milestone records, interaction history
- **Immutability**: Once created, must not be rewritten or deleted
- **Cross-linking**: Should reference Procedural and LTM when relevance is high
- **Searchability**: Must be indexed for AI-powered retrieval

#### Semantic Memory (SEM)
- **Purpose**: Timeless facts, terminology, core definitions, relationships
- **Persistence**: No auto-expiry, must be version-controlled
- **Updates**: Changes require historical tracking and justification

#### Procedural Memory (PRO)
- **Purpose**: Methods, how-to guides, operational playbooks
- **Updates**: Must be logged with complete history tracking
- **Validation**: Changes require testing and approval workflows

---

## III. AI TAGGING SYSTEM REQUIREMENTS

### Tagging Architecture
All memory must implement the hybrid AI tagging system:

#### Structured Tags
- Format: `type:value`, `intent:purpose`, `priority:level`
- Examples: `type:conversation`, `intent:debug`, `priority:high`
- Purpose: Fast, predictable searching and filtering

#### Semantic Tags
- AI-generated, context-rich descriptors
- Examples: `troubleshooting`, `python_error`, `async_issue`
- Generated by TagIntelligenceEngine with embeddings

#### Compound Tags
- Bridge structured and semantic worlds
- Format: `structured+semantic`
- Examples: `type:conversation+troubleshooting`, `intent:debug+python_error`

### Tag DNA System
Each AI-generated tag must include:
```json
{
  "tag": "async_debugging",
  "semantic_vector": [0.2, 0.8, 0.1, ...],
  "related_keywords": ["async", "await", "asyncio", "coroutine"],
  "context_patterns": ["error traceback", "async def", "event loop"],
  "usage_frequency": 15,
  "effectiveness_score": 0.87,
  "last_updated": "06-19_02-15PM"
}
```

### Tag Learning Requirements
- Tags must self-improve through usage tracking
- Effectiveness scores updated based on retrieval success
- Similar tags automatically merged when appropriate
- New tag combinations suggested based on patterns

---

## IV. TIMESTAMP STANDARDS

### Global Timestamp Format
**Mandatory Format**: `%m-%d_%I-%M%p`  
**Example**: `06-19_02-15PM`  
**Applies To**: All filenames, logs, state files, metadata, JSON entries

### Prohibited Formats
- ISO format: `%Y-%m-%d %H:%M:%S`
- 24-hour time: `%H:%M`
- Slash separators: `%m/%d` (Windows incompatible)
- Any format not matching the global standard

### Enforcement
- All agents must validate timestamp format before writing files
- Automatic conversion required when legacy formats detected
- Violations logged in `timestamp_violations.log`

---

## V. AGENT AUTONOMY & ORCHESTRATION

### Autonomy Requirements
All agents must be fully autonomous:
- Run automatically based on triggers/conditions
- Monitor and react to system changes without human intervention
- Operate in background processes with comprehensive logging
- Self-recover from errors when possible

### Prohibited Dependencies
- Manual GUI buttons for agent activation
- Manual triggers or user intervention for routine operations
- Blocking operations that require user response
- Hardcoded API keys or credentials

### Orchestration Rules
- One agent focus at a time for external AI assistants
- Agents must coordinate through shared state files
- Conflicts resolved through orchestrator agent mediation
- All agent interactions logged for transparency

---

## VI. SCHEMA MANAGEMENT PROTOCOLS

### Schema Updater Rules
- Must not run constantly or trigger every few seconds
- Only update when actual changes detected in watched folders
- Reuse existing `schema_logs` folder, never create duplicates
- Validate folder existence before proceeding with updates
- Path determination must use `os.path.abspath` for reliability

### Schema Output Requirements
- `project_schema_log.md`: Plain text descriptions of changes
- `schema.md`: Folder tree structure only
- `full_schema.md`: Complete folder tree with contents
- `schema_history.md`: Chronological change log

### Change Detection
- Log folder move events with source and destination paths
- Avoid redundant entries by checking for actual changes
- Propagate updates to related JSON and markdown files
- Maintain consistency across all schema documentation

---

## VII. MEMORY RENAMER AGENT SPECIFICATIONS

### File Processing Requirements
- Target directory: `CHAT_LOGS_DIR` (full_chat_logs folder)
- Process only `.md` files within target directory
- Use OpenAI API (`gpt-3.5-turbo`) for intelligent naming
- Load API key from `.env` file using `python-dotenv`

### Filename Standards
- Extract original date from existing filenames
- Preserve original timestamps when renaming
- Use global timestamp format for new timestamps
- Handle 12-hour time conversions correctly (AM/PM)

### Error Handling & Logging
- Create `rename_chat_logs_debug.log` for detailed logging
- Log every processing step with exact file paths
- Check directory existence and file accessibility
- Handle exceptions gracefully with detailed error messages
- Normalize paths to avoid mixed slash issues

### Processing Logic
- Skip files identified as non-markdown with log entry
- Generate descriptive names using OpenAI API
- Retain original filename if metadata extraction fails
- Create missing directories with `os.makedirs(exist_ok=True)`

---

## VIII. PROMOTION & ARCHIVAL PROTOCOLS

### Promotion Requirements
Promotion from STM, WM, or EPI to LTM must preserve:
- Complete timestamp chain
- Source file path and original location
- Builder identity and documented intent
- All associated tags and metadata
- Change justification and approval record

### Archival Standards
- No "cleaning" of memory without explicit builder confirmation
- Archival folders maintain identical access patterns to live folders
- Compressed archives must preserve full metadata
- Archival must maintain searchability and tag relationships

### Quality Gates
- Automated validation of promotion criteria
- Tag quality assessment before archival
- Broken link detection and repair
- Integrity verification post-promotion

---

## IX. GUI & INTERFACE GOVERNANCE

### Interface Restrictions
- No GUI button may delete memory without irreversible confirmation modal
- GUI search, load, and view functions default to **read-only**
- All write operations must respect memory type and tagging logic
- Bulk operations require additional safeguards and logging

### User Experience Requirements
- Context injection must be seamless and non-intrusive
- Search results prioritized by AI effectiveness scores
- Tag suggestions provided during content creation
- Historical view available for all memory types

---

## X. PROTECTED CLASSIFICATIONS

### Protected Tags
- `#neverdelete`: Files locked against any deletion
- `#corelogic`: System-level functions and enforcement rules
- `#builderintent`: Builder voice, values, and architecture decisions
- `#systemcritical`: Infrastructure components
- `#aitagged`: Content enhanced with AI semantic tags

### Protected Directories
- `a_memory_core/`: System infrastructure (highest protection)
- `core_logic.md`: This governance document
- `tag_intelligence_engine.py`: AI tagging infrastructure
- Agent state and manifest files

### Access Control
- Builder-level changes require explicit authorization
- Agent modifications limited to designated operational areas
- System files protected against accidental modification
- Backup creation mandatory before protected file changes

---

## XI. ENFORCEMENT & VIOLATION PROTOCOLS

### Enforcement Agents
Primary enforcement responsibility:
- `memory_logic_enforcer_agent`: Active rule validation
- `memory_orchestrator_agent`: System-wide audit and coordination
- `memory_context_router_agent`: Tag and retrieval compliance

### Violation Response
When violations detected:
1. Immediate logging to `violation_log.json` with full context
2. Automatic correction attempt (if safe and possible)
3. Alert generation for builder review if critical
4. Documentation in `agent_interactions.log`
5. System integrity verification post-correction

### Audit Requirements
- Daily system integrity checks
- Weekly tag effectiveness analysis
- Monthly agent performance review
- Quarterly full system validation

---

## XII. PERFORMANCE & OPTIMIZATION

### Caching Strategy
- Tag effectiveness scores cached for fast retrieval
- Semantic search results cached with expiration
- File metadata indexed for rapid access
- Query patterns tracked for optimization

### Resource Management
- Background processes managed to prevent resource conflicts
- Memory usage monitored and optimized
- Disk space alerts for critical thresholds
- Performance metrics tracked and reported

---

## XIII. INTEGRATION & EXTENSION PROTOCOLS

### External System Integration
- API endpoints must respect core logic constraints
- Third-party tools cannot override memory retention rules
- Integration logging required for all external interactions
- Security validation for all external connections

### Extension Development
- New agents must implement standard interfaces
- Tag intelligence integration mandatory for memory-touching components
- State management follows established patterns
- Testing requirements include core logic compliance validation

---

## XIV. DISASTER RECOVERY & CONTINUITY

### Backup Requirements
- Daily automated backups of critical memory
- Tag database redundancy maintained
- Agent state preservation across system restarts
- Configuration version control

### Recovery Procedures
- System restoration prioritizes memory integrity
- Tag relationships validated post-recovery
- Agent orchestration reestablished automatically
- Builder notification for manual verification requirements

---

## XV. MAINTENANCE & UPDATES

### Update Authorization
This core logic may only be updated by:
- The System Builder (Stephen Alexander)
- Through signed amendments in `memory/core_logic/amendments/`
- Emergency updates with post-facto builder approval

### Change Management
- All changes tracked with complete audit trail
- Impact assessment required for major modifications
- Rollback procedures tested and documented
- Agent notification system for logic updates

---

## COPYRIGHT & INTELLECTUAL PROPERTY NOTICE

© 2025 Stephen Alexander. All rights reserved.

The CommandCore Memory System architecture, including all associated intent, structure, operational philosophy, and AI tagging methodologies, are the intellectual property of Stephen Alexander.

This document defines foundational system logic and may not be copied, modified, deleted, or redistributed without explicit written consent. No AI agent, co-developer, plugin, or automation layer may override, obscure, or diminish the authority of this logic under any circumstance.

This file is binding for all present and future iterations of the CommandCore OS platform, including derivative works, GUI-integrated systems, and external integrations. Violation of these terms constitutes a breach of system integrity and intellectual property rights.

**System Integrity Pledge**: This logic governs all system behavior and agent decision-making. Any deviation from these principles must be explicitly justified and approved through proper channels.

---

**Document Authority**: ABSOLUTE  
**Enforcement Level**: SYSTEM-WIDE  
**Next Review**: 07-19_02-15PM  
**Builder Signature**: Stephen Alexander - 06-19_02-15PM


---
**Last Auto-Updated:** 2025-07-30 23:14:35


## Autonomous Improvements

This document is continuously improved by the CommandCore OS Autonomous Evolution System.

### Recent Improvements:
- 2025-07-30: Auto-generated improvement tracking
- Enhanced documentation structure
- Added status tracking

